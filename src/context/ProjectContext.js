import React, { createContext, useState, useContext } from 'react';
import spotifyClone from "../assets/img/spotify-clone.gif";
import devlinks from "../assets/img/devlinks.gif";
import detonaRalph from "../assets/img/detona-ralph.gif";
import jogoDaMemoria from "../assets/img/jogo-da-memoria.gif";
import petLife from "../assets/img/pet-life.gif";
import travelgram from "../assets/img/travelgram.gif";

const ProjectContext = createContext();

export function useProject() {
  return useContext(ProjectContext);
}

export function ProjectProvider({ children }) {
  const [projetoSelecionado, setProjetoSelecionado] = useState(null);

  const projetosData = [
    { 
      id: 'spotify-clone', 
      nome: 'Spotify Clone', 
      descricao: 'O projeto Spotify-Clone representa a concretização do desafio proposto pela Imersão Front-End 2ª Edição da Alura, com o objetivo de recriar a página inicial do Spotify para desktop. No entanto, fui além do escopo inicial, adotando uma abordagem mobile-first para garantir uma experiência de usuário otimizada em dispositivos móveis, e subsequentemente adaptando o layout para telas maiores através de media queries. O projeto foi desenvolvido utilizando HTML, CSS e JavaScript puro, demonstrando um domínio das tecnologias fundamentais da web. Para enriquecer a funcionalidade, implementei uma busca dinâmica por artistas utilizando uma API local simplificada, que eu mesmo desenvolvi especificamente para este projeto. A interação com esta API local foi realizada através de fetch e then para o tratamento e manipulação dos dados retornados, permitindo uma experiência de busca fluida e responsiva dentro do ambiente de desenvolvimento. Demonstrei grande atenção aos detalhes visuais e de interação, buscando a máxima fidelidade à página inicial oficial do Spotify. A precisão na reprodução dos elementos da interface foi uma prioridade, visando criar um clone com a maior semelhança possível ao original. Adicionalmente, o projeto conta com um sistema de rotas de navegação entre as páginas, proporcionando uma experiência de usuário consistente e intuitiva. Implementei um layout de carrossel dinâmico para a exibição dos artistas, replicando a dinâmica de apresentação da plataforma original. Um destaque especial é a implementação de um elemento dinâmico no carrossel, com comportamento sensível ao dia e horário. Este elemento é exibido apenas durante um período específico, simulando a natureza efêmera de certas promoções ou conteúdos da plataforma original. Através deste projeto, Spotify-Clone, demonstro um domínio de conceitos de responsividade (mobile-first e media queries), desenvolvimento com HTML, CSS e JavaScript puro, implementação e consumo de APIs (através da minha API local), manipulação de dados, criação de rotas de navegação, desenvolvimento de layouts dinâmicos (carrossel) e atenção meticulosa à fidelidade do design e comportamento da interface do usuário.', 
      linkProjeto: 'https://brunotxrs.github.io/Spotify-Clone/', linkGithub: 'https://github.com/brunotxrs/Spotify-Clone', imagem: spotifyClone 
    },
    { 
      id: 'devlinks', 
      nome: 'DevLinks', 
      descricao: 'O projeto DevLinks surgiu como um desafio prático do curso Discover, representando meu primeiro contato formal com as tecnologias fundamentais do desenvolvimento web: HTML, CSS e JavaScript. A versão inicial deste projeto, desenvolvida com estas tecnologias puras, encontra-se disponível na branch first-version do repositório. Posteriormente, buscando aprimorar minhas habilidades e aplicar os conhecimentos adquiridos em React.js, decidi reconstruir o DevLinks do zero utilizando esta biblioteca. Este foi meu primeiro projeto de refatoração e reimplementação em React, onde pude aplicar uma abordagem mobile-first, garantindo uma experiência de usuário fluida e responsiva em dispositivos móveis, e adaptando o layout para telas maiores através do uso estratégico de media queries. Durante o desenvolvimento em React, explorei o poder do Context API para implementar a funcionalidade de alternância de temas entre claro e escuro, utilizando a biblioteca React Power. A estrutura do projeto foi completamente remodelada em componentes React, o que resultou em um código mais modular, reutilizável e de fácil manutenção. Através da evolução do DevLinks, desde sua concepção inicial em HTML, CSS e JavaScript puro até sua reimplementação em React com práticas de desenvolvimento responsivo e gerenciamento de estado com Context API, demonstro uma progressão constante no meu aprendizado e a capacidade de aplicar novas tecnologias e conceitos para otimizar e modernizar projetos existentes.', linkProjeto: 'https://dev-links-z8hu.vercel.app/', 
      linkGithub: 'https://github.com/brunotxrs/dev-links', 
      imagem: devlinks 
    },
    {
      id: 'detona-ralph', 
      nome: 'Jogo Detona Ralph', 
      descricao: 'O projeto Detona Ralph Game surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresenta uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo. Como um passo além no meu desenvolvimento, decidi reimplementar o Detona Ralph Game do zero utilizando a biblioteca React.js. Nesta nova versão, adotei uma abordagem mobile-first para garantir uma experiência jogável em dispositivos móveis, com adaptações para telas maiores através de media queries, demonstrando minhas habilidades em design responsivo. A arquitetura da aplicação foi expandida para incluir múltiplas telas, com navegação fluida e sutil proporcionada pela biblioteca react-router-dom. A tela inicial (HomeScreen) apresenta um botão de "Start" e um formulário para coletar o nome do jogador. Implementei uma validação de entrada que exige um mínimo de 3 e um máximo de 5 caracteres para habilitar a progressão para a próxima tela. Os dados do jogador (nome) são armazenados globalmente utilizando o Context API para fácil acesso em outras partes da aplicação. A tela principal do jogo (GameScreen) concentra a ação, exibindo informações cruciais como tempo restante, vidas, pontos e o nome do jogador. A lógica do jogo implementa dinâmicas como ganho de vida extra e pontos ao acertar o Ralph, e perda de vida ao errar. O tempo é uma contagem regressiva, e ao zerar, o jogo termina (GameOver). Ao final da partida, o jogador é direcionado para a tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo jogadores fictícios com pontuações predefinidas). Implementei uma lógica de atualização dinâmica do ranking, onde a posição do jogador é ajustada caso sua pontuação ultrapasse a de outros jogadores, podendo alcançar o primeiro ou segundo lugar. Um botão permite ao jogador retornar à tela inicial (HomeScreen) para jogar novamente. No desenvolvimento desta versão em React.js, utilizei extensivamente o Context API para gerenciar o estado da aplicação de forma centralizada e eficiente, e o react-router-dom para uma navegação suave entre as telas. Além disso, empreguei diversos Hooks do React, como useState, useContext, useEffect, useRef e useNavigate, demonstrando um domínio das funcionalidades e padrões modernos do React. Através deste projeto, Detona Ralph Game, evidencio minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React e a capacidade de transformar um conceito de jogo simples em uma aplicação React completa e interativa.', 
      linkProjeto: 'https://detona-ralph-game-gamma.vercel.app/', linkGithub: 'https://github.com/brunotxrs/detona-ralph-game', imagem: detonaRalph
    },
    { 
      id: 'jogo-da-memoria', nome: 'Jogo da Memória', descricao: 'O projeto Jogo da Memória surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresentava uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo da memória. Em uma etapa posterior de aprendizado e buscando consolidar meus conhecimentos em React.js, decidi reimplementar o Jogo da Memória do zero utilizando esta biblioteca. Nesta nova versão, apliquei uma abordagem mobile-first para garantir uma experiência de jogo responsiva em dispositivos móveis, com adaptações para telas maiores através do uso de media queries. A arquitetura da aplicação foi estruturada em múltiplas telas, com uma navegação fluida e sutil implementada através da biblioteca react-router-dom. A tela inicial (HomeScreen) serve como ponto de entrada, apresentando um campo para inserir o nome do jogador, uma seleção de níveis de dificuldade (baixo, médio, difícil) e um botão de "Start". Implementei uma validação robusta nesta tela, exigindo que o jogador preencha o nome e selecione um nível antes de prosseguir. Caso algum elemento seja omitido, mensagens de alerta claras informam o usuário sobre o que falta. Ao cumprir os requisitos da tela inicial, o jogador é direcionado para a tela principal do jogo (GameScreen). Esta tela exibe um cabeçalho com o nome do jogador, um contador de tempo regressivo e um indicador de vidas. O tempo, ao atingir zero, encerra a partida e leva o jogador à tela de placar. As vidas são decrementadas a cada erro de correspondência de pares. A pontuação do jogador, embora não visível durante a partida, é rastreada internamente para ser exibida na tela de placar. Ao finalizar o jogo, o jogador é apresentado à tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo pontuações predefinidas para jogadores fictícios). A organização deste ranking é dinâmica, ajustando a posição do jogador caso sua pontuação supere a de outros, podendo alcançar o primeiro ou segundo lugar. Uma implementação visual adicional para o primeiro lugar inclui a exibição de uma animação em GIF de fogos de artifício e um efeito sonoro. A apresentação do placar também varia conforme o nível de dificuldade selecionado e as pontuações alcançadas. Um botão permite ao jogador retornar à tela inicial para iniciar um novo jogo. No desenvolvimento desta versão em React.js, utilizei o Context API para gerenciar o estado da aplicação de forma centralizada, o react-router-dom para a navegação entre as telas e diversos Hooks do React, como useState, useContext, useEffect, useMemo, useRef, useNavigate e useLocation. A aplicação desses Hooks demonstra um domínio das funcionalidades e padrões modernos do React para criar uma experiência de jogo interativa e completa. Através deste projeto, Jogo da Memória, demonstro minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React, implementação de lógica de jogo complexa, validação de formulários e a criação de interfaces de usuário dinâmicas e envolventes.', 
      linkProjeto: 'https://memory-game-iota-blond.vercel.app/', linkGithub: 'https://github.com/brunotxrs/memory-game', 
      imagem: jogoDaMemoria 
    },
    { 
      id: 'petlife', nome: 'PetLife', descricao: 'O projeto PetLife consiste na criação de um website fictício para uma clínica veterinária, oferecendo informações sobre serviços de saúde, bem-estar e produtos para animais de estimação. O desafio inicial do projeto era desenvolver uma interface intuitiva focada em telas desktop. Aplicando minhas habilidades de desenvolvedor front-end, expandi o escopo original para adotar uma abordagem mobile-first. Esta metodologia garante uma experiência de navegação fluida e consistente tanto em dispositivos móveis quanto em desktops, com a adaptação do layout realizada através do uso estratégico de media queries. O desenvolvimento deste projeto utilizou as tecnologias fundamentais da web: HTML, CSS e JavaScript puro. Para otimizar a manutenção e escalabilidade do CSS, implementei o uso de custom properties (variáveis CSS), permitindo uma gestão de estilos mais eficiente e centralizada. Adicionalmente, o projeto emprega um arquivo de orquestração CSS. Esta técnica envolve a criação de um único arquivo CSS principal, responsável por importar todas as demais folhas de estilo específicas das diferentes seções e componentes do website. Esta abordagem simplifica a vinculação de estilos no arquivo HTML, exigindo apenas um único link para o arquivo principal, e contribui significativamente para a organização e a manutenibilidade do projeto. Através do PetLife, demonstro proficiência em desenvolvimento responsivo (mobile-first e media queries), o uso eficaz de variáveis CSS para manutenção de estilos e a implementação de estratégias de organização de CSS (arquivo de orquestração) para facilitar a gestão de projetos web.', 
      linkProjeto: 'https://brunotxrs.github.io/PetLife/', 
      linkGithub: 'https://github.com/brunotxrs/PetLife', 
      imagem: petLife 
    },
    { 
      id: 'travelgram', nome: 'Travelgram', descricao: 'Travelgram é um projeto de layout para um perfil de rede social dedicado a fotos de viagem. Desenvolvido originalmente como parte da formação Full-stack da Rocketseat com foco em telas desktop, eu expandi o escopo inicial para aplicar minhas habilidades em desenvolvimento responsivo. Adotei uma abordagem mobile-first para construir a interface, garantindo uma experiência de navegação fluida e adaptável tanto em dispositivos móveis quanto em telas desktop, através da implementação de media queries. A construção do layout utilizou as tecnologias fundamentais da web: HTML e CSS puro. Para otimizar a manutenibilidade e a organização dos estilos, empreguei custom properties (variáveis CSS), facilitando a gestão e a modificação das cores e outros valores de estilo em todo o projeto. Além disso, implementei um arquivo CSS de orquestração. Este arquivo centralizado tem a função de importar todas as folhas de estilo específicas dos diferentes componentes e seções do layout. Ao vincular apenas este arquivo de orquestração no HTML, simplifico a estrutura e facilito a manutenção de todo o conjunto de estilos do projeto. Através do Travelgram, demonstro minhas habilidades em criar layouts responsivos com a metodologia mobile-first e media queries, a utilização eficiente de variáveis CSS para aprimorar a manutenibilidade e a aplicação de um arquivo de orquestração CSS para uma gestão de estilos organizada e eficaz.', 
      linkProjeto: 'https://brunotxrs.github.io/travelgram/', 
      linkGithub: 'https://github.com/brunotxrs/travelgram', 
      imagem: travelgram 
    },
  ];

  const selecionarProjeto = (id) => {
    setProjetoSelecionado(id);
  };

  const fecharProjeto = () => {
    setProjetoSelecionado(null);
  };

  return (
    <ProjectContext.Provider value={{ projetoSelecionado, projetosData, selecionarProjeto, fecharProjeto }}>
      {children}
    </ProjectContext.Provider>
  );
}