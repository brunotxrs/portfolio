import React, { createContext, useState, useContext } from 'react';
import spotifyClone from "../assets/img/spotify-clone.gif";
import devlinks from "../assets/img/devlinks.gif";
import detonaRalph from "../assets/img/detona-ralph.gif";
import jogoDaMemoria from "../assets/img/jogo-da-memoria.gif";
import petLife from "../assets/img/pet-life.gif";
import travelgram from "../assets/img/travelgram.gif";

const ProjectContext = createContext();

export function useProject() {
  return useContext(ProjectContext);
}

export function ProjectProvider({ children }) {
  const [projetoSelecionado, setProjetoSelecionado] = useState(null);

  const projetosData = [
    { 
      id: 'spotify-clone', 
      nome: 'Spotify Clone', 
      descricao: {
        pt:'O projeto Spotify-Clone representa a concretização do desafio proposto pela Imersão Front-End 2ª Edição da Alura, com o objetivo de recriar a página inicial do Spotify para desktop. No entanto, fui além do escopo inicial, adotando uma abordagem mobile-first para garantir uma experiência de usuário otimizada em dispositivos móveis, e subsequentemente adaptando o layout para telas maiores através de media queries. O projeto foi desenvolvido utilizando HTML, CSS e JavaScript puro, demonstrando um domínio das tecnologias fundamentais da web. Para enriquecer a funcionalidade, implementei uma busca dinâmica por artistas utilizando uma API local simplificada, que eu mesmo desenvolvi especificamente para este projeto. A interação com esta API local foi realizada através de fetch e then para o tratamento e manipulação dos dados retornados, permitindo uma experiência de busca fluida e responsiva dentro do ambiente de desenvolvimento. Demonstrei grande atenção aos detalhes visuais e de interação, buscando a máxima fidelidade à página inicial oficial do Spotify. A precisão na reprodução dos elementos da interface foi uma prioridade, visando criar um clone com a maior semelhança possível ao original. Adicionalmente, o projeto conta com um sistema de rotas de navegação entre as páginas, proporcionando uma experiência de usuário consistente e intuitiva. Implementei um layout de carrossel dinâmico para a exibição dos artistas, replicando a dinâmica de apresentação da plataforma original. Um destaque especial é a implementação de um elemento dinâmico no carrossel, com comportamento sensível ao dia e horário. Este elemento é exibido apenas durante um período específico, simulando a natureza efêmera de certas promoções ou conteúdos da plataforma original. Através deste projeto, Spotify-Clone, demonstro um domínio de conceitos de responsividade (mobile-first e media queries), desenvolvimento com HTML, CSS e JavaScript puro, implementação e consumo de APIs (através da minha API local), manipulação de dados, criação de rotas de navegação, desenvolvimento de layouts dinâmicos (carrossel) e atenção meticulosa à fidelidade do design e comportamento da interface do usuário.',
        en:"The Spotify-Clone project represents the realization of the challenge proposed by Alura's Front-End Immersion 2nd Edition, with the objective of recreating the Spotify desktop homepage. However, I went beyond the initial scope, adopting a mobile-first approach to ensure an optimized user experience on mobile devices, and subsequently adapting the layout for larger screens through media queries. The project was developed using HTML, CSS, and pure JavaScript, demonstrating a mastery of fundamental web technologies. To enrich the functionality, I implemented a dynamic artist search using a simplified local API, which I developed specifically for this project. Interaction with this local API was carried out using fetch and then for handling and manipulating the returned data, allowing for a fluid and responsive search experience within the development environment. I demonstrated great attention to visual and interaction details, aiming for maximum fidelity to the official Spotify homepage. The precision in reproducing the interface elements was a priority, aiming to create a clone with the greatest possible resemblance to the original. Additionally, the project features a navigation routing system between pages, providing a consistent and intuitive user experience. I implemented a dynamic carousel layout for displaying artists, replicating the presentation dynamics of the original platform. A special highlight is the implementation of a dynamic element in the carousel, with behavior sensitive to the day and time. This element is displayed only during a specific period, simulating the ephemeral nature of certain promotions or content on the original platform. Through this project, Spotify-Clone, I demonstrate a mastery of responsiveness concepts (mobile-first and media queries), development with HTML, CSS, and pure JavaScript, implementation and consumption of APIs (through my local API), data manipulation, creation of navigation routes, development of dynamic layouts (carousel), and meticulous attention to the fidelity of the design and behavior of the user interface." ,
      }, 
      linkProjeto: 'https://brunotxrs.github.io/Spotify-Clone/', linkGithub: 'https://github.com/brunotxrs/Spotify-Clone', imagem: spotifyClone 
    },
    { 
      id: 'devlinks', 
      nome: 'DevLinks', 
      descricao: {
        pt:'O projeto DevLinks surgiu como um desafio prático do curso Discover, representando meu primeiro contato formal com as tecnologias fundamentais do desenvolvimento web: HTML, CSS e JavaScript. A versão inicial deste projeto, desenvolvida com estas tecnologias puras, encontra-se disponível na branch first-version do repositório. Posteriormente, buscando aprimorar minhas habilidades e aplicar os conhecimentos adquiridos em React.js, decidi reconstruir o DevLinks do zero utilizando esta biblioteca. Este foi meu primeiro projeto de refatoração e reimplementação em React, onde pude aplicar uma abordagem mobile-first, garantindo uma experiência de usuário fluida e responsiva em dispositivos móveis, e adaptando o layout para telas maiores através do uso estratégico de media queries. Durante o desenvolvimento em React, explorei o poder do Context API para implementar a funcionalidade de alternância de temas entre claro e escuro, utilizando a biblioteca React Power. A estrutura do projeto foi completamente remodelada em componentes React, o que resultou em um código mais modular, reutilizável e de fácil manutenção. Através da evolução do DevLinks, desde sua concepção inicial em HTML, CSS e JavaScript puro até sua reimplementação em React com práticas de desenvolvimento responsivo e gerenciamento de estado com Context API, demonstro uma progressão constante no meu aprendizado e a capacidade de aplicar novas tecnologias e conceitos para otimizar e modernizar projetos existentes.',
        en: 'The DevLinks project emerged as a practical challenge from the Discover course, representing my first formal contact with the fundamental technologies of web development: HTML, CSS, and JavaScript. The initial version of this project, developed with these pure technologies, is available in the first-version branch of the repository. Subsequently, seeking to enhance my skills and apply the knowledge acquired in React.js, I decided to rebuild DevLinks from scratch using this library. This was my first project of refactoring and reimplementation in React, where I could apply a mobile-first approach, ensuring a fluid and responsive user experience on mobile devices, and adapting the layout for larger screens through the strategic use of media queries. During the React development, I explored the power of the Context API to implement the light and dark theme toggle functionality, utilizing the React Power library. The project structure was completely remodeled into React components, which resulted in more modular, reusable, and easily maintainable code. Through the evolution of DevLinks, from its initial conception in pure HTML, CSS, and JavaScript to its reimplementation in React with responsive development practices and state management with Context API, I demonstrate a constant progression in my learning and the ability to apply new technologies and concepts to optimize and modernize existing projects.',
      } , linkProjeto: 'https://dev-links-z8hu.vercel.app/', 
      linkGithub: 'https://github.com/brunotxrs/dev-links', 
      imagem: devlinks 
    },
    {
      id: 'detona-ralph', 
      nome: 'Jogo Detona Ralph', 
      descricao: {
        pt: 'O projeto Detona Ralph Game surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresenta uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo. Como um passo além no meu desenvolvimento, decidi reimplementar o Detona Ralph Game do zero utilizando a biblioteca React.js. Nesta nova versão, adotei uma abordagem mobile-first para garantir uma experiência jogável em dispositivos móveis, com adaptações para telas maiores através de media queries, demonstrando minhas habilidades em design responsivo. A arquitetura da aplicação foi expandida para incluir múltiplas telas, com navegação fluida e sutil proporcionada pela biblioteca react-router-dom. A tela inicial (HomeScreen) apresenta um botão de "Start" e um formulário para coletar o nome do jogador. Implementei uma validação de entrada que exige um mínimo de 3 e um máximo de 5 caracteres para habilitar a progressão para a próxima tela. Os dados do jogador (nome) são armazenados globalmente utilizando o Context API para fácil acesso em outras partes da aplicação. A tela principal do jogo (GameScreen) concentra a ação, exibindo informações cruciais como tempo restante, vidas, pontos e o nome do jogador. A lógica do jogo implementa dinâmicas como ganho de vida extra e pontos ao acertar o Ralph, e perda de vida ao errar. O tempo é uma contagem regressiva, e ao zerar, o jogo termina (GameOver). Ao final da partida, o jogador é direcionado para a tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo jogadores fictícios com pontuações predefinidas). Implementei uma lógica de atualização dinâmica do ranking, onde a posição do jogador é ajustada caso sua pontuação ultrapasse a de outros jogadores, podendo alcançar o primeiro ou segundo lugar. Um botão permite ao jogador retornar à tela inicial (HomeScreen) para jogar novamente. No desenvolvimento desta versão em React.js, utilizei extensivamente o Context API para gerenciar o estado da aplicação de forma centralizada e eficiente, e o react-router-dom para uma navegação suave entre as telas. Além disso, empreguei diversos Hooks do React, como useState, useContext, useEffect, useRef e useNavigate, demonstrando um domínio das funcionalidades e padrões modernos do React. Através deste projeto, Detona Ralph Game, evidencio minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React e a capacidade de transformar um conceito de jogo simples em uma aplicação React completa e interativa.',
        
        en: `The Detona Ralph Game project emerged as a practical challenge from the DIO Front-End Developer course, with the initial objective of practicing my pure JavaScript skills. The initial version of the game, developed during this learning phase, is available in the first-version branch and features a single dynamic screen built with HTML, CSS, and JavaScript, focused on the game's core mechanics. As a step further in my development, I decided to reimplement the Detona Ralph Game from scratch using the React.js library. In this new version, I adopted a mobile-first approach to ensure a playable experience on mobile devices, with adaptations for larger screens through media queries, demonstrating my responsive design skills. The application architecture was expanded to include multiple screens, with fluid and subtle navigation provided by the react-router-dom library. The initial screen (HomeScreen) features a "Start" button and a form to collect the player's name. I implemented input validation that requires a minimum of 3 and a maximum of 5 characters to enable progression to the next screen. Player data (name) is stored globally using the Context API for easy access in other parts of the application. The main game screen (GameScreen) focuses on the action, displaying crucial information such as remaining time, lives, score, and the player's name. The game logic implements dynamics such as gaining extra lives and points by hitting Ralph, and losing lives by missing. Time is a countdown, and when it reaches zero, the game ends (GameOver). At the end of the match, the player is directed to the scoreboard screen (DashboardScreen), which displays a ranking of players (including fictitious players with predefined scores). I implemented a dynamic ranking update logic, where the player's position is adjusted if their score surpasses that of other players, potentially reaching the first or second place. A button allows the player to return to the initial screen (HomeScreen) to play again. In the development of this version in React.js, I extensively used the Context API to manage the application state centrally and efficiently, and react-router-dom for smooth navigation between screens. Additionally, I employed various React Hooks, such as useState, useContext, useEffect, useRef, and useNavigate, demonstrating a mastery of modern React functionalities and patterns. Through this project, Detona Ralph Game, I showcase my skills in responsive development (mobile-first, media queries), creation of multi-screen applications with routing (react-router-dom), global state management with Context API, manipulation of React Hooks, and the ability to transform a simple game concept into a complete and interactive React application.`,
      }, 
      linkProjeto: 'https://detona-ralph-game-gamma.vercel.app/', linkGithub: 'https://github.com/brunotxrs/detona-ralph-game', imagem: detonaRalph
    },
    { 
      id: 'jogo-da-memoria', nome: 'Jogo da Memória', descricao: 'O projeto Jogo da Memória surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresentava uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo da memória. Em uma etapa posterior de aprendizado e buscando consolidar meus conhecimentos em React.js, decidi reimplementar o Jogo da Memória do zero utilizando esta biblioteca. Nesta nova versão, apliquei uma abordagem mobile-first para garantir uma experiência de jogo responsiva em dispositivos móveis, com adaptações para telas maiores através do uso de media queries. A arquitetura da aplicação foi estruturada em múltiplas telas, com uma navegação fluida e sutil implementada através da biblioteca react-router-dom. A tela inicial (HomeScreen) serve como ponto de entrada, apresentando um campo para inserir o nome do jogador, uma seleção de níveis de dificuldade (baixo, médio, difícil) e um botão de "Start". Implementei uma validação robusta nesta tela, exigindo que o jogador preencha o nome e selecione um nível antes de prosseguir. Caso algum elemento seja omitido, mensagens de alerta claras informam o usuário sobre o que falta. Ao cumprir os requisitos da tela inicial, o jogador é direcionado para a tela principal do jogo (GameScreen). Esta tela exibe um cabeçalho com o nome do jogador, um contador de tempo regressivo e um indicador de vidas. O tempo, ao atingir zero, encerra a partida e leva o jogador à tela de placar. As vidas são decrementadas a cada erro de correspondência de pares. A pontuação do jogador, embora não visível durante a partida, é rastreada internamente para ser exibida na tela de placar. Ao finalizar o jogo, o jogador é apresentado à tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo pontuações predefinidas para jogadores fictícios). A organização deste ranking é dinâmica, ajustando a posição do jogador caso sua pontuação supere a de outros, podendo alcançar o primeiro ou segundo lugar. Uma implementação visual adicional para o primeiro lugar inclui a exibição de uma animação em GIF de fogos de artifício e um efeito sonoro. A apresentação do placar também varia conforme o nível de dificuldade selecionado e as pontuações alcançadas. Um botão permite ao jogador retornar à tela inicial para iniciar um novo jogo. No desenvolvimento desta versão em React.js, utilizei o Context API para gerenciar o estado da aplicação de forma centralizada, o react-router-dom para a navegação entre as telas e diversos Hooks do React, como useState, useContext, useEffect, useMemo, useRef, useNavigate e useLocation. A aplicação desses Hooks demonstra um domínio das funcionalidades e padrões modernos do React para criar uma experiência de jogo interativa e completa. Através deste projeto, Jogo da Memória, demonstro minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React, implementação de lógica de jogo complexa, validação de formulários e a criação de interfaces de usuário dinâmicas e envolventes.', 
      linkProjeto: 'https://memory-game-iota-blond.vercel.app/', linkGithub: 'https://github.com/brunotxrs/memory-game', 
      imagem: jogoDaMemoria 
    },
    { 
      id: 'petlife', nome: 'PetLife', descricao: 'O projeto PetLife consiste na criação de um website fictício para uma clínica veterinária, oferecendo informações sobre serviços de saúde, bem-estar e produtos para animais de estimação. O desafio inicial do projeto era desenvolver uma interface intuitiva focada em telas desktop. Aplicando minhas habilidades de desenvolvedor front-end, expandi o escopo original para adotar uma abordagem mobile-first. Esta metodologia garante uma experiência de navegação fluida e consistente tanto em dispositivos móveis quanto em desktops, com a adaptação do layout realizada através do uso estratégico de media queries. O desenvolvimento deste projeto utilizou as tecnologias fundamentais da web: HTML, CSS e JavaScript puro. Para otimizar a manutenção e escalabilidade do CSS, implementei o uso de custom properties (variáveis CSS), permitindo uma gestão de estilos mais eficiente e centralizada. Adicionalmente, o projeto emprega um arquivo de orquestração CSS. Esta técnica envolve a criação de um único arquivo CSS principal, responsável por importar todas as demais folhas de estilo específicas das diferentes seções e componentes do website. Esta abordagem simplifica a vinculação de estilos no arquivo HTML, exigindo apenas um único link para o arquivo principal, e contribui significativamente para a organização e a manutenibilidade do projeto. Através do PetLife, demonstro proficiência em desenvolvimento responsivo (mobile-first e media queries), o uso eficaz de variáveis CSS para manutenção de estilos e a implementação de estratégias de organização de CSS (arquivo de orquestração) para facilitar a gestão de projetos web.', 
      linkProjeto: 'https://brunotxrs.github.io/PetLife/', 
      linkGithub: 'https://github.com/brunotxrs/PetLife', 
      imagem: petLife 
    },
    { 
      id: 'travelgram', nome: 'Travelgram', descricao: 'Travelgram é um projeto de layout para um perfil de rede social dedicado a fotos de viagem. Desenvolvido originalmente como parte da formação Full-stack da Rocketseat com foco em telas desktop, eu expandi o escopo inicial para aplicar minhas habilidades em desenvolvimento responsivo. Adotei uma abordagem mobile-first para construir a interface, garantindo uma experiência de navegação fluida e adaptável tanto em dispositivos móveis quanto em telas desktop, através da implementação de media queries. A construção do layout utilizou as tecnologias fundamentais da web: HTML e CSS puro. Para otimizar a manutenibilidade e a organização dos estilos, empreguei custom properties (variáveis CSS), facilitando a gestão e a modificação das cores e outros valores de estilo em todo o projeto. Além disso, implementei um arquivo CSS de orquestração. Este arquivo centralizado tem a função de importar todas as folhas de estilo específicas dos diferentes componentes e seções do layout. Ao vincular apenas este arquivo de orquestração no HTML, simplifico a estrutura e facilito a manutenção de todo o conjunto de estilos do projeto. Através do Travelgram, demonstro minhas habilidades em criar layouts responsivos com a metodologia mobile-first e media queries, a utilização eficiente de variáveis CSS para aprimorar a manutenibilidade e a aplicação de um arquivo de orquestração CSS para uma gestão de estilos organizada e eficaz.', 
      linkProjeto: 'https://brunotxrs.github.io/travelgram/', 
      linkGithub: 'https://github.com/brunotxrs/travelgram', 
      imagem: travelgram 
    },
  ];

  const selecionarProjeto = (id) => {
    setProjetoSelecionado(id);
  };

  const fecharProjeto = () => {
    setProjetoSelecionado(null);
  };

  return (
    <ProjectContext.Provider value={{ projetoSelecionado, projetosData, selecionarProjeto, fecharProjeto }}>
      {children}
    </ProjectContext.Provider>
  );
}