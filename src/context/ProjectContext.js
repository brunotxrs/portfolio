import React, { createContext, useState, useContext } from 'react';
import spotifyClone from "../assets/img/spotify-clone.gif";
import devlinks from "../assets/img/devlinks.gif";
import detonaRalph from "../assets/img/detona-ralph.gif";
import jogoDaMemoria from "../assets/img/jogo-da-memoria.gif";
import petLife from "../assets/img/pet-life.gif";
import travelgram from "../assets/img/travelgram.gif";

const ProjectContext = createContext();

export function useProject() {
  return useContext(ProjectContext);
}

export function ProjectProvider({ children }) {
  const [projetoSelecionado, setProjetoSelecionado] = useState(null);

  const projetosData = [
    { 
      id: 'spotify-clone', 
      nome: 'Spotify Clone', 
      descricao: {
        pt:'O projeto Spotify-Clone representa a concretização do desafio proposto pela Imersão Front-End 2ª Edição da Alura, com o objetivo de recriar a página inicial do Spotify para desktop. No entanto, fui além do escopo inicial, adotando uma abordagem mobile-first para garantir uma experiência de usuário otimizada em dispositivos móveis, e subsequentemente adaptando o layout para telas maiores através de media queries. O projeto foi desenvolvido utilizando HTML, CSS e JavaScript puro, demonstrando um domínio das tecnologias fundamentais da web. Para enriquecer a funcionalidade, implementei uma busca dinâmica por artistas utilizando uma API local simplificada, que eu mesmo desenvolvi especificamente para este projeto. A interação com esta API local foi realizada através de fetch e then para o tratamento e manipulação dos dados retornados, permitindo uma experiência de busca fluida e responsiva dentro do ambiente de desenvolvimento. Demonstrei grande atenção aos detalhes visuais e de interação, buscando a máxima fidelidade à página inicial oficial do Spotify. A precisão na reprodução dos elementos da interface foi uma prioridade, visando criar um clone com a maior semelhança possível ao original. Adicionalmente, o projeto conta com um sistema de rotas de navegação entre as páginas, proporcionando uma experiência de usuário consistente e intuitiva. Implementei um layout de carrossel dinâmico para a exibição dos artistas, replicando a dinâmica de apresentação da plataforma original. Um destaque especial é a implementação de um elemento dinâmico no carrossel, com comportamento sensível ao dia e horário. Este elemento é exibido apenas durante um período específico, simulando a natureza efêmera de certas promoções ou conteúdos da plataforma original. Através deste projeto, Spotify-Clone, demonstro um domínio de conceitos de responsividade (mobile-first e media queries), desenvolvimento com HTML, CSS e JavaScript puro, implementação e consumo de APIs (através da minha API local), manipulação de dados, criação de rotas de navegação, desenvolvimento de layouts dinâmicos (carrossel) e atenção meticulosa à fidelidade do design e comportamento da interface do usuário.',
        en:"The Spotify-Clone project represents the realization of the challenge proposed by Alura's Front-End Immersion 2nd Edition, with the objective of recreating the Spotify desktop homepage. However, I went beyond the initial scope, adopting a mobile-first approach to ensure an optimized user experience on mobile devices, and subsequently adapting the layout for larger screens through media queries. The project was developed using HTML, CSS, and pure JavaScript, demonstrating a mastery of fundamental web technologies. To enrich the functionality, I implemented a dynamic artist search using a simplified local API, which I developed specifically for this project. Interaction with this local API was carried out using fetch and then for handling and manipulating the returned data, allowing for a fluid and responsive search experience within the development environment. I demonstrated great attention to visual and interaction details, aiming for maximum fidelity to the official Spotify homepage. The precision in reproducing the interface elements was a priority, aiming to create a clone with the greatest possible resemblance to the original. Additionally, the project features a navigation routing system between pages, providing a consistent and intuitive user experience. I implemented a dynamic carousel layout for displaying artists, replicating the presentation dynamics of the original platform. A special highlight is the implementation of a dynamic element in the carousel, with behavior sensitive to the day and time. This element is displayed only during a specific period, simulating the ephemeral nature of certain promotions or content on the original platform. Through this project, Spotify-Clone, I demonstrate a mastery of responsiveness concepts (mobile-first and media queries), development with HTML, CSS, and pure JavaScript, implementation and consumption of APIs (through my local API), data manipulation, creation of navigation routes, development of dynamic layouts (carousel), and meticulous attention to the fidelity of the design and behavior of the user interface." ,
      }, 
      linkProjeto: 'https://brunotxrs.github.io/Spotify-Clone/', linkGithub: 'https://github.com/brunotxrs/Spotify-Clone', imagem: spotifyClone 
    },
    { 
      id: 'devlinks', 
      nome: 'DevLinks', 
      descricao: {
        pt:'O projeto DevLinks surgiu como um desafio prático do curso Discover, representando meu primeiro contato formal com as tecnologias fundamentais do desenvolvimento web: HTML, CSS e JavaScript. A versão inicial deste projeto, desenvolvida com estas tecnologias puras, encontra-se disponível na branch first-version do repositório. Posteriormente, buscando aprimorar minhas habilidades e aplicar os conhecimentos adquiridos em React.js, decidi reconstruir o DevLinks do zero utilizando esta biblioteca. Este foi meu primeiro projeto de refatoração e reimplementação em React, onde pude aplicar uma abordagem mobile-first, garantindo uma experiência de usuário fluida e responsiva em dispositivos móveis, e adaptando o layout para telas maiores através do uso estratégico de media queries. Durante o desenvolvimento em React, explorei o poder do Context API para implementar a funcionalidade de alternância de temas entre claro e escuro, utilizando a biblioteca React Power. A estrutura do projeto foi completamente remodelada em componentes React, o que resultou em um código mais modular, reutilizável e de fácil manutenção. Através da evolução do DevLinks, desde sua concepção inicial em HTML, CSS e JavaScript puro até sua reimplementação em React com práticas de desenvolvimento responsivo e gerenciamento de estado com Context API, demonstro uma progressão constante no meu aprendizado e a capacidade de aplicar novas tecnologias e conceitos para otimizar e modernizar projetos existentes.',
        en: 'The DevLinks project emerged as a practical challenge from the Discover course, representing my first formal contact with the fundamental technologies of web development: HTML, CSS, and JavaScript. The initial version of this project, developed with these pure technologies, is available in the first-version branch of the repository. Subsequently, seeking to enhance my skills and apply the knowledge acquired in React.js, I decided to rebuild DevLinks from scratch using this library. This was my first project of refactoring and reimplementation in React, where I could apply a mobile-first approach, ensuring a fluid and responsive user experience on mobile devices, and adapting the layout for larger screens through the strategic use of media queries. During the React development, I explored the power of the Context API to implement the light and dark theme toggle functionality, utilizing the React Power library. The project structure was completely remodeled into React components, which resulted in more modular, reusable, and easily maintainable code. Through the evolution of DevLinks, from its initial conception in pure HTML, CSS, and JavaScript to its reimplementation in React with responsive development practices and state management with Context API, I demonstrate a constant progression in my learning and the ability to apply new technologies and concepts to optimize and modernize existing projects.',
      } , linkProjeto: 'https://dev-links-z8hu.vercel.app/', 
      linkGithub: 'https://github.com/brunotxrs/dev-links', 
      imagem: devlinks 
    },
    {
      id: 'detona-ralph', 
      nome: 'Jogo Detona Ralph', 
      descricao: {
        pt: 'O projeto Detona Ralph Game surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresenta uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo. Como um passo além no meu desenvolvimento, decidi reimplementar o Detona Ralph Game do zero utilizando a biblioteca React.js. Nesta nova versão, adotei uma abordagem mobile-first para garantir uma experiência jogável em dispositivos móveis, com adaptações para telas maiores através de media queries, demonstrando minhas habilidades em design responsivo. A arquitetura da aplicação foi expandida para incluir múltiplas telas, com navegação fluida e sutil proporcionada pela biblioteca react-router-dom. A tela inicial (HomeScreen) apresenta um botão de "Start" e um formulário para coletar o nome do jogador. Implementei uma validação de entrada que exige um mínimo de 3 e um máximo de 5 caracteres para habilitar a progressão para a próxima tela. Os dados do jogador (nome) são armazenados globalmente utilizando o Context API para fácil acesso em outras partes da aplicação. A tela principal do jogo (GameScreen) concentra a ação, exibindo informações cruciais como tempo restante, vidas, pontos e o nome do jogador. A lógica do jogo implementa dinâmicas como ganho de vida extra e pontos ao acertar o Ralph, e perda de vida ao errar. O tempo é uma contagem regressiva, e ao zerar, o jogo termina (GameOver). Ao final da partida, o jogador é direcionado para a tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo jogadores fictícios com pontuações predefinidas). Implementei uma lógica de atualização dinâmica do ranking, onde a posição do jogador é ajustada caso sua pontuação ultrapasse a de outros jogadores, podendo alcançar o primeiro ou segundo lugar. Um botão permite ao jogador retornar à tela inicial (HomeScreen) para jogar novamente. No desenvolvimento desta versão em React.js, utilizei extensivamente o Context API para gerenciar o estado da aplicação de forma centralizada e eficiente, e o react-router-dom para uma navegação suave entre as telas. Além disso, empreguei diversos Hooks do React, como useState, useContext, useEffect, useRef e useNavigate, demonstrando um domínio das funcionalidades e padrões modernos do React. Através deste projeto, Detona Ralph Game, evidencio minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React e a capacidade de transformar um conceito de jogo simples em uma aplicação React completa e interativa.',
        
        en: `The Detona Ralph Game project emerged as a practical challenge from the DIO Front-End Developer course, with the initial objective of practicing my pure JavaScript skills. The initial version of the game, developed during this learning phase, is available in the first-version branch and features a single dynamic screen built with HTML, CSS, and JavaScript, focused on the game's core mechanics. As a step further in my development, I decided to reimplement the Detona Ralph Game from scratch using the React.js library. In this new version, I adopted a mobile-first approach to ensure a playable experience on mobile devices, with adaptations for larger screens through media queries, demonstrating my responsive design skills. The application architecture was expanded to include multiple screens, with fluid and subtle navigation provided by the react-router-dom library. The initial screen (HomeScreen) features a "Start" button and a form to collect the player's name. I implemented input validation that requires a minimum of 3 and a maximum of 5 characters to enable progression to the next screen. Player data (name) is stored globally using the Context API for easy access in other parts of the application. The main game screen (GameScreen) focuses on the action, displaying crucial information such as remaining time, lives, score, and the player's name. The game logic implements dynamics such as gaining extra lives and points by hitting Ralph, and losing lives by missing. Time is a countdown, and when it reaches zero, the game ends (GameOver). At the end of the match, the player is directed to the scoreboard screen (DashboardScreen), which displays a ranking of players (including fictitious players with predefined scores). I implemented a dynamic ranking update logic, where the player's position is adjusted if their score surpasses that of other players, potentially reaching the first or second place. A button allows the player to return to the initial screen (HomeScreen) to play again. In the development of this version in React.js, I extensively used the Context API to manage the application state centrally and efficiently, and react-router-dom for smooth navigation between screens. Additionally, I employed various React Hooks, such as useState, useContext, useEffect, useRef, and useNavigate, demonstrating a mastery of modern React functionalities and patterns. Through this project, Detona Ralph Game, I showcase my skills in responsive development (mobile-first, media queries), creation of multi-screen applications with routing (react-router-dom), global state management with Context API, manipulation of React Hooks, and the ability to transform a simple game concept into a complete and interactive React application.`,
      }, 
      linkProjeto: 'https://detona-ralph-game-gamma.vercel.app/', linkGithub: 'https://github.com/brunotxrs/detona-ralph-game', imagem: detonaRalph
    },
    { 
      id: 'jogo-da-memoria', nome: 'Jogo da Memória', descricao: {
        pt: 'O projeto Jogo da Memória surgiu como um desafio prático do curso Desenvolvedor Front-End da DIO, com o objetivo inicial de praticar minhas habilidades em JavaScript puro. A versão inicial do jogo, desenvolvida durante essa fase de aprendizado esta disponível na branch first-version, apresentava uma única tela dinâmica construída com HTML, CSS e JavaScript, focada na mecânica principal do jogo da memória. Em uma etapa posterior de aprendizado e buscando consolidar meus conhecimentos em React.js, decidi reimplementar o Jogo da Memória do zero utilizando esta biblioteca. Nesta nova versão, apliquei uma abordagem mobile-first para garantir uma experiência de jogo responsiva em dispositivos móveis, com adaptações para telas maiores através do uso de media queries. A arquitetura da aplicação foi estruturada em múltiplas telas, com uma navegação fluida e sutil implementada através da biblioteca react-router-dom. A tela inicial (HomeScreen) serve como ponto de entrada, apresentando um campo para inserir o nome do jogador, uma seleção de níveis de dificuldade (baixo, médio, difícil) e um botão de "Start". Implementei uma validação robusta nesta tela, exigindo que o jogador preencha o nome e selecione um nível antes de prosseguir. Caso algum elemento seja omitido, mensagens de alerta claras informam o usuário sobre o que falta. Ao cumprir os requisitos da tela inicial, o jogador é direcionado para a tela principal do jogo (GameScreen). Esta tela exibe um cabeçalho com o nome do jogador, um contador de tempo regressivo e um indicador de vidas. O tempo, ao atingir zero, encerra a partida e leva o jogador à tela de placar. As vidas são decrementadas a cada erro de correspondência de pares. A pontuação do jogador, embora não visível durante a partida, é rastreada internamente para ser exibida na tela de placar. Ao finalizar o jogo, o jogador é apresentado à tela de placar (DashboardScreen), que exibe um ranking de jogadores (incluindo pontuações predefinidas para jogadores fictícios). A organização deste ranking é dinâmica, ajustando a posição do jogador caso sua pontuação supere a de outros, podendo alcançar o primeiro ou segundo lugar. Uma implementação visual adicional para o primeiro lugar inclui a exibição de uma animação em GIF de fogos de artifício e um efeito sonoro. A apresentação do placar também varia conforme o nível de dificuldade selecionado e as pontuações alcançadas. Um botão permite ao jogador retornar à tela inicial para iniciar um novo jogo. No desenvolvimento desta versão em React.js, utilizei o Context API para gerenciar o estado da aplicação de forma centralizada, o react-router-dom para a navegação entre as telas e diversos Hooks do React, como useState, useContext, useEffect, useMemo, useRef, useNavigate e useLocation. A aplicação desses Hooks demonstra um domínio das funcionalidades e padrões modernos do React para criar uma experiência de jogo interativa e completa. Através deste projeto, Jogo da Memória, demonstro minhas habilidades em desenvolvimento responsivo (mobile-first, media queries), criação de aplicações multi-tela com roteamento (react-router-dom), gerenciamento de estado global com Context API, manipulação de Hooks do React, implementação de lógica de jogo complexa, validação de formulários e a criação de interfaces de usuário dinâmicas e envolventes.',
        en: `The Memory Game project emerged as a practical challenge from the DIO Front-End Developer course, with the initial objective of practicing my pure JavaScript skills. The initial version of the game, developed during this learning phase, is available in the first-version branch and featured a single dynamic screen built with HTML, CSS, and JavaScript, focused on the core mechanics of the memory game. In a later stage of learning and seeking to consolidate my knowledge in React.js, I decided to reimplement the Memory Game from scratch using this library. In this new version, I applied a mobile-first approach to ensure a responsive gaming experience on mobile devices, with adaptations for larger screens through the use of media queries. The application architecture was structured into multiple screens, with fluid and subtle navigation implemented through the react-router-dom library. The initial screen (HomeScreen) serves as the entry point, presenting a field to enter the player's name, a selection of difficulty levels (easy, medium, hard), and a "Start" button. I implemented robust validation on this screen, requiring the player to fill in their name and select a level before proceeding. If any element is omitted, clear alert messages inform the user about what is missing. Upon meeting the requirements of the initial screen, the player is directed to the main game screen (GameScreen). This screen displays a header with the player's name, a countdown timer, and a life indicator. The timer, upon reaching zero, ends the game and takes the player to the scoreboard screen. Lives are decremented with each incorrect pair matching. The player's score, although not visible during the game, is tracked internally to be displayed on the scoreboard screen. Upon finishing the game, the player is presented with the scoreboard screen (DashboardScreen), which displays a ranking of players (including predefined scores for fictitious players). The organization of this ranking is dynamic, adjusting the player's position if their score surpasses that of others, potentially reaching first or second place. An additional visual implementation for first place includes the display of a fireworks GIF animation and a sound effect. The presentation of the scoreboard also varies according to the selected difficulty level and the scores achieved. A button allows the player to return to the initial screen to start a new game. In the development of this version in React.js, I extensively used the Context API to manage the application state centrally, react-router-dom for navigation between screens, and various React Hooks, such as useState, useContext, useEffect, useMemo, useRef, useNavigate, and useLocation. The application of these Hooks demonstrates a mastery of modern React functionalities and patterns to create a complete and interactive gaming experience. Through this project, Memory Game, I showcase my skills in responsive development (mobile-first, media queries), creation of multi-screen applications with routing (react-router-dom), global state management with Context API, manipulation of React Hooks, implementation of complex game logic, form validation, and the creation of dynamic and engaging user interfaces.`,
      }, 
      linkProjeto: 'https://memory-game-iota-blond.vercel.app/', linkGithub: 'https://github.com/brunotxrs/memory-game', 
      imagem: jogoDaMemoria 
    },
    { 
      id: 'petlife', 
      nome: 'PetLife', 
      descricao: {
        pt: 'O projeto PetLife consiste na criação de um website fictício para uma clínica veterinária, oferecendo informações sobre serviços de saúde, bem-estar e produtos para animais de estimação. O desafio inicial do projeto era desenvolver uma interface intuitiva focada em telas desktop. Aplicando minhas habilidades de desenvolvedor front-end, expandi o escopo original para adotar uma abordagem mobile-first. Esta metodologia garante uma experiência de navegação fluida e consistente tanto em dispositivos móveis quanto em desktops, com a adaptação do layout realizada através do uso estratégico de media queries. O desenvolvimento deste projeto utilizou as tecnologias fundamentais da web: HTML, CSS e JavaScript puro. Para otimizar a manutenção e escalabilidade do CSS, implementei o uso de custom properties (variáveis CSS), permitindo uma gestão de estilos mais eficiente e centralizada. Adicionalmente, o projeto emprega um arquivo de orquestração CSS. Esta técnica envolve a criação de um único arquivo CSS principal, responsável por importar todas as demais folhas de estilo específicas das diferentes seções e componentes do website. Esta abordagem simplifica a vinculação de estilos no arquivo HTML, exigindo apenas um único link para o arquivo principal, e contribui significativamente para a organização e a manutenibilidade do projeto. Através do PetLife, demonstro proficiência em desenvolvimento responsivo (mobile-first e media queries), o uso eficaz de variáveis CSS para manutenção de estilos e a implementação de estratégias de organização de CSS (arquivo de orquestração) para facilitar a gestão de projetos web.',
        en: `The PetLife project consists of the creation of a fictitious website for a veterinary clinic, offering information about health services, well-being, and products for pets. The initial challenge of the project was to develop an intuitive interface focused on desktop screens. Applying my front-end developer skills, I expanded the original scope to adopt a mobile-first approach. This methodology ensures a fluid and consistent navigation experience on both mobile devices and desktops, with layout adaptation achieved through the strategic use of media queries. The development of this project utilized fundamental web technologies: HTML, CSS, and pure JavaScript. To optimize the maintenance and scalability of the CSS, I implemented the use of custom properties (CSS variables), allowing for more efficient and centralized style management. Additionally, the project employs a CSS orchestration file. This technique involves creating a single main CSS file, responsible for importing all other specific stylesheets for the different sections and components of the website. This approach simplifies the linking of styles in the HTML file, requiring only a single link to the main file, and significantly contributes to the organization and maintainability of the project. Through PetLife, I demonstrate proficiency in responsive development (mobile-first and media queries), the effective use of CSS variables for style maintenance, and the implementation of CSS organization strategies (orchestration file) to facilitate the management of web projects.`,
      }, 
      linkProjeto: 'https://brunotxrs.github.io/PetLife/', 
      linkGithub: 'https://github.com/brunotxrs/PetLife', 
      imagem: petLife 
    },
    { 
      id: 'travelgram', 
      nome: 'Travelgram', 
      descricao: {
        pt: 'Travelgram é um projeto de layout para um perfil de rede social dedicado a fotos de viagem. Desenvolvido originalmente como parte da formação Full-stack da Rocketseat com foco em telas desktop, eu expandi o escopo inicial para aplicar minhas habilidades em desenvolvimento responsivo. Adotei uma abordagem mobile-first para construir a interface, garantindo uma experiência de navegação fluida e adaptável tanto em dispositivos móveis quanto em telas desktop, através da implementação de media queries. A construção do layout utilizou as tecnologias fundamentais da web: HTML e CSS puro. Para otimizar a manutenibilidade e a organização dos estilos, empreguei custom properties (variáveis CSS), facilitando a gestão e a modificação das cores e outros valores de estilo em todo o projeto. Além disso, implementei um arquivo CSS de orquestração. Este arquivo centralizado tem a função de importar todas as folhas de estilo específicas dos diferentes componentes e seções do layout. Ao vincular apenas este arquivo de orquestração no HTML, simplifico a estrutura e facilito a manutenção de todo o conjunto de estilos do projeto. Através do Travelgram, demonstro minhas habilidades em criar layouts responsivos com a metodologia mobile-first e media queries, a utilização eficiente de variáveis CSS para aprimorar a manutenibilidade e a aplicação de um arquivo de orquestração CSS para uma gestão de estilos organizada e eficaz.',
        en: `Travelgram is a layout project for a social media profile dedicated to travel photos. Originally developed as part of the Rocketseat Full-stack training with a focus on desktop screens, I expanded the initial scope to apply my responsive development skills. I adopted a mobile-first approach to build the interface, ensuring a fluid and adaptable navigation experience on both mobile devices and desktop screens through the implementation of media queries. The layout construction utilized fundamental web technologies: pure HTML and CSS. To optimize the maintainability and organization of styles, I employed custom properties (CSS variables), facilitating the management and modification of colors and other style values throughout the project. Furthermore, I implemented a CSS orchestration file. This centralized file has the function of importing all specific stylesheets for the different components and sections of the layout. By linking only this orchestration file in the HTML, I simplify the structure and facilitate the maintenance of the entire set of project styles. Through Travelgram, I demonstrate my skills in creating responsive layouts with the mobile-first methodology and media queries, the efficient use of CSS variables to enhance maintainability, and the application of a CSS orchestration file for organized and effective style management.`,
      }, 
      linkProjeto: 'https://brunotxrs.github.io/travelgram/', 
      linkGithub: 'https://github.com/brunotxrs/travelgram', 
      imagem: travelgram 
    },
  ];

  const selecionarProjeto = (id) => {
    setProjetoSelecionado(id);
  };

  const fecharProjeto = () => {
    setProjetoSelecionado(null);
  };

  return (
    <ProjectContext.Provider value={{ projetoSelecionado, projetosData, selecionarProjeto, fecharProjeto }}>
      {children}
    </ProjectContext.Provider>
  );
}